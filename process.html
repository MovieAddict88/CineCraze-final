<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pre-process TMDB Data</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #status { margin-top: 20px; white-space: pre-wrap; }
        #download { margin-top: 20px; display: none; }
    </style>
</head>
<body>
    <h1>Pre-process TMDB Data</h1>
    <p>This script will fetch data from your JSON file, enrich it with data from TMDB, and then allow you to download the new, combined JSON file.</p>
    <input type="file" id="jsonFile" accept=".json">
    <button id="start">Start Processing</button>
    <div id="status"></div>
    <a id="download" href="#" download="enriched_playlist.json">Download Enriched JSON</a>

    <script>
        const TMDB_API_KEY = '871c8ec045dba340e55b032a0546948c';

        const startBtn = document.getElementById('start');
        const statusEl = document.getElementById('status');
        const downloadEl = document.getElementById('download');
        const jsonFileInput = document.getElementById('jsonFile');

        startBtn.addEventListener('click', async () => {
            if (jsonFileInput.files.length === 0) {
                alert('Please select a JSON file to process.');
                return;
            }

            startBtn.disabled = true;
            statusEl.textContent = 'Reading JSON file...';

            try {
                const file = jsonFileInput.files[0];
                const cineData = JSON.parse(await file.text());

                statusEl.textContent = 'Enriching data with TMDB...';

                for (const category of cineData.Categories) {
                    for (const entry of category.Entries) {
                        const type = category.MainCategory.toLowerCase().includes('movie') ? 'movie' : 'series';
                        const tmdbData = await fetchTmdbData(entry.Title, type);
                        const mpdDrm = entry.mpdDrm;
                        
                        // Validate and sanitize mpdDrm before preserving it
                        const sanitizedMpdDrm = sanitizeMpdDrm(mpdDrm);
                        
                        Object.assign(entry, tmdbData);
                        if (sanitizedMpdDrm) {
                            entry.mpdDrm = sanitizedMpdDrm;
                        }
                        statusEl.textContent += `\nProcessed: ${entry.Title}`;
                        await new Promise(resolve => setTimeout(resolve, 100)); // Rate limit to avoid overwhelming the API
                    }
                }

                statusEl.textContent += '\n\nProcessing complete!';
                const enrichedJson = JSON.stringify(cineData, null, 2);
                const base64Data = btoa(unescape(encodeURIComponent(enrichedJson)));
                const blob = new Blob([base64Data], { type: 'text/plain' });
                downloadEl.href = URL.createObjectURL(blob);
                downloadEl.style.display = 'block';

            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
            }
        });

        async function fetchTmdbData(title, type) {
            const searchType = type === 'series' ? 'tv' : 'movie';
            const url = `https://api.themoviedb.org/3/search/${searchType}?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(title)}`;

            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    const item = data.results[0];
                    return {
                        Description: item.overview,
                        Year: type === 'series' ? (item.first_air_date ? item.first_air_date.split('-')[0] : '') : (item.release_date ? item.release_date.split('-')[0] : ''),
                        Rating: item.vote_average ? item.vote_average.toFixed(1) : 'N/A',
                        Poster: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : '',
                        Thumbnail: item.backdrop_path ? `https://image.tmdb.org/t/p/w500${item.backdrop_path}` : '',
                    };
                }
            } catch (error) {
                console.error(`Failed to fetch TMDB data for ${title}:`, error);
            }
            return {};
        }

        // Validate URL format and prevent malicious URLs
        function isValidUrl(url) {
            if (!url || typeof url !== 'string') return false;
            
            try {
                const urlObj = new URL(url);
                // Only allow http/https protocols
                if (!['http:', 'https:'].includes(urlObj.protocol)) {
                    return false;
                }
                // Prevent local file access and private IPs
                if (urlObj.hostname === 'localhost' || 
                    urlObj.hostname.startsWith('127.') ||
                    urlObj.hostname.startsWith('192.168.') ||
                    urlObj.hostname.startsWith('10.') ||
                    urlObj.hostname.match(/^172\.(1[6-9]|2[0-9]|3[01])\./)) {
                    return false;
                }
                return true;
            } catch (e) {
                return false;
            }
        }

        // Sanitize and validate mpdDrm configuration
        function sanitizeMpdDrm(mpdDrm) {
            if (!mpdDrm || typeof mpdDrm !== 'object') {
                return null;
            }

            // Create a safe copy and validate structure
            const validatedConfig = {};
            
            // Validate each DRM system
            const allowedDrmSystems = ['com.widevine.alpha', 'com.microsoft.playready', 'com.adobe.primetime'];
            
            for (const [key, value] of Object.entries(mpdDrm)) {
                if (allowedDrmSystems.includes(key) && value && typeof value === 'object') {
                    validatedConfig[key] = {};
                    
                    // Validate license server URL
                    if (value.serverURL && isValidUrl(value.serverURL)) {
                        validatedConfig[key].serverURL = value.serverURL;
                    }
                    
                    // Validate headers (if present)
                    if (value.httpRequestHeaders && typeof value.httpRequestHeaders === 'object') {
                        validatedConfig[key].httpRequestHeaders = {};
                        // Only allow safe headers
                        const allowedHeaders = ['authorization', 'content-type', 'x-custom-data'];
                        for (const [headerKey, headerValue] of Object.entries(value.httpRequestHeaders)) {
                            if (allowedHeaders.includes(headerKey.toLowerCase()) && 
                                typeof headerValue === 'string' && 
                                headerValue.length < 1000) { // Limit header value length
                                validatedConfig[key].httpRequestHeaders[headerKey] = headerValue;
                            }
                        }
                    }
                }
            }

            // Log DRM validation for audit purposes
            console.log('DRM config validated during processing');
            
            return Object.keys(validatedConfig).length > 0 ? validatedConfig : null;
        }
    </script>
</body>
</html>
